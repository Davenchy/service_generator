#!/usr/bin/env bash
# This script will generate a systemd service file
# Dracula Theme is used: https://draculatheme.com/

# Globals
SYSD="/usr/lib/systemd/system/"

# reset terminal
reset

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
WHITE='\033[0;37m'
NC='\033[0m' # No Color

# define display and write functions

# Function to display an error message and exit
display_error() {
    echo -e "${RED}Error: $1${NC}"
    [ -z "$2" ] && exit 1
}

# Function to display a success message
display_success() {
    echo -e "${GREEN}Success:${WHITE} $1${NC}"
}

# Function to display a warning message
display_warning() {
		echo -e "${YELLOW}WARNING:${WHITE} $1${NC}"
}

# Function to display an info message
display_info() {
		echo -e "${BLUE}INFO:${WHITE} $1${NC}"
}

# check required tools are installed
required_tools=("fzf" "tput" "getent" "vim" "xclip" "id")
for tool in "${required_tools[@]}"; do
    [ -z "$(command -v "$tool")" ] \
        && display_error "$tool is not installed, please install it."
done

# color function to define color with fallback values
# check below defined colors for more examples
color() {
	local color_ansi="$1"
	local color_8bit="$2"
	local color_24bit="$3"
	local code="\e[3"

	if [ "$(tput colors)" -eq 8 ]; then
		echo -ne "${code}8;5;${color_8bit}m"
	elif [ "$(tput colors)" -eq 256 ]; then
		echo -ne "${code}8;2;${color_24bit}m"
	else
		local color=7 # white by default
		case "$color_ansi" in
			black) color=0 ;;
			red) color=1 ;;
			green) color=2 ;;
			yellow) color=3 ;;
			blue) color=4 ;;
			magenta) color=5 ;;
			cyan) color=6 ;;
			white) color=7 ;;
		esac
		echo -ne "${code}${color}m"
	fi
}

# convert hex color to decimal so it can be used
# Example: color_hex2dec 0xff 0x00 0x00 -> 255;0;0
color_hex2dec() {
	printf "%d;%d;%d" "$1" "$2" "$3"
}

# Redfine colors to use Dracula Theme and the fallback colors if not supported
# https://draculatheme.com
RED="$(color red 196 "$(color_hex2dec 0xEA 0x51 0xB2)")"
GREEN="$(color green 83 "$(color_hex2dec 0x00 0xF7 0x69)")"
YELLOW="$(color yellow 227 "$(color_hex2dec 0xEB 0xFF 0x87)")"
BLUE="$(color blue 111 "$(color_hex2dec 0x62 0xD6 0xE8)")"
MAGENTA="$(color magenta 200 "$(color_hex2dec 0xB4 0x5B 0xCF)")"
CYAN="$(color cyan 45 "$(color_hex2dec 0xA1 0xEF 0xE4)")"
WHITE="$(color white 231 "$(color_hex2dec 0xE9 0xE9 0xF4)")"
NC="$(echo -en '\e[0m')"
RESET="$(echo -en '\e[0m')"

# FZF default confiuration
export FZF_DEFAULT_OPTS='--color=fg:#f8f8f2,bg:#282a36,hl:#bd93f9 --color=fg+:#f8f8f2,bg+:#44475a,hl+:#bd93f9 --color=info:#ffb86c,prompt:#50fa7b,pointer:#ff79c6 --color=marker:#ff79c6,spinner:#ffb86c,header:#6272a4 --cycle --marker=x --height=50%'

# Action Scripts

# Read and parse a service file
function ReadService {
    # get the service file path
    local service_path="$1"
    # get the service file basename e.g. NetworkManager.service
    local service_file
    service_file="$(basename "$service_path")"
    # remove the extension e.g. NetworkManager
    local service_name=${service_file%.service}

    # export a global array contains all service file sections and directives
    declare -gxA SERVICE=()
    local section="" # the current section for the next parsed directives

    # read service file line by line
    while read -r line; do
        # skip empty lines
        [ -z "$line" ] && continue
        # skip comments
        [ "$(expr "$line" : '^ *#.*$')" -gt 0 ] && continue

        # get section name if line is a section header
        sectionCase="$(expr "$line" : '^\[\(.*\)\]$')"
        # check if line is a directive and a value/s
        directiveCase="$(expr "$line" : '^.*=.*$')"

        if [ -n "$sectionCase" ]; then
            section="$sectionCase" # set as a section for the next parsed directives
        elif [ "$directiveCase" -gt 0 ]; then
            # check if a section was set for this directive
            [ -z "$section" ] && display_error "Directive line without section: $line"
            # parse the directive line for key and value
            IFS='=' read -ra args <<< "$line"
            # set the key as section:directive and the value to the SERVICE global array
            SERVICE["$section:${args[0]}"]="${args[1]}"
        else
            display_error "Failed to read line: $line" 1
        fi
    done < "$service_path"

    # Generate array of service sections
    ServiceSections
}

# Print all sections and directives using the parsed data at ReadService function
function PrintService {
    # loop through all sections stored in the global array which generated by ServiceSections function
    for section in "${SERVICE_SECTIONS[@]}"; do
        # print section name
        echo -e "${MAGENTA}[${section}]${RESET}"
        # generate array of directives(SECTION_DIRECTIVES) for the section
        SectionDirectives "$section"
        # loop through all directives stored in the global array which generated by SectionDirectives function
        for directive in "${!SECTION_DIRECTIVES[@]}"; do
            # get the directive value
            local value="${SECTION_DIRECTIVES[$directive]}"
            # print directive and its value
            echo -e "${BLUE}$directive:\n\t\t${YELLOW}${value}${RESET}\n"
        done
        echo
    done
}

# Generate global array (SERVICE_SECTIONS) of service sections
function ServiceSections {
    # declare a global array that contains all service sections
    declare -gxa SERVICE_SECTIONS=()

    # loop through all keys stored in the global array which generated by ReadService function
    # key format -> section:directive
    for key in "${!SERVICE[@]}"; do
        local section
        # get the section part from the key
        section="$(KeySection "$key")"
        # if the section already pushed to the array before then skip
        [[ "${SERVICE_SECTIONS[*]}" =~ $section ]] && continue
        # else push the section to the array
        SERVICE_SECTIONS[${#SERVICE_SECTIONS[@]}]="$section"
    done
}

# Generate global array (SECTION_DIRECTIVES) of directives for a section
function SectionDirectives {
    # the section to get its directives
    local section="$1"
    # define a global array that contains all section directives
    declare -gxA SECTION_DIRECTIVES=()

    # loop through all keys stored in the global array which generated by ReadService function
    for key in "${!SERVICE[@]}"; do
        # check if the key contains the section name at its section part otherwise skip
        [ "$(expr "$key" : "^${section}:.*\$")" -eq 0 ] && continue
        # get the directive name
        directive="$(KeyDirective "$key")"
        # set the directive value to the global array
        SECTION_DIRECTIVES["$directive"]="${SERVICE[$key]}"
    done
}

# Returns the section part from the key
function KeySection {
    cut -d: -f1 <<< "$1"
}

# Returns the directive part from the key
function KeyDirective {
    cut -d: -f2 <<< "$1"
}

# Returns the value using the key
function KeyValue {
    echo "${SERVICE["$1"]}"
}

# This function saves all data in SERVICE array to the service file path
function SaveService {
    # the service file full path
    local service_path="$1"
    
    # Create a temporary file to store the modified service content
    local temp_file
    temp_file="$(mktemp)"
    
    # Write the array content to the temporary file
    for section in "${SERVICE_SECTIONS[@]}"; do
        echo -e "[${section}]" >> "$temp_file"
        SectionDirectives "$section"
        for directive in "${!SECTION_DIRECTIVES[@]}"; do
            local value="${SECTION_DIRECTIVES[$directive]}"
            echo -e "${directive}=${value}" >> "$temp_file"
        done
        echo >> "$temp_file"
    done

    # Overwrite the original service file with the temporary file
    if sudo cp "$temp_file" "$service_path"; then
        display_success "Service file saved: ${service_path}"
        ReloadSystemD
    else
        display_error "Failed to save the service file: ${service_path}" 1
        return 1
    fi

    # Cleanup: Remove the temporary file
    rm -f "$temp_file"
}

# Print the help message for the edit mode
function DisplayEditModeHelp {
    declare -A options=(
    [List]="List the service file with colored current values"
    [List Section]="List all directives with its values for a selected section"
    ["Copy Value"]="Select key and copy its value to system clipboard"
	[Set]="Select (Section:Directive) and set its value, set empty value to remove the directive"
	["Set Manual"]="Use manual key(Section:Directive) to create/set/remove directive"
    ["Set Current Working Directory"]="Sets (Service:WorkingDirectory) to current working directory"
    ["Set User"]="Sets (Service:User) to the selected user"
    ["Set Group"]="Sets (Service:Group) to the selected group"
    ["Set Type"]="Sets (Service:Type) to the selected service types"
	["Control Mode"]="Enter Control Mode for the current service"
	[Help]="Print this help message"
	[Reload]="Reload the current service file and discard changes"
	[Save]="Save the current changes to the service file, Reload SystemD Daemons and return back to the control mode"
	[Back]="Discard current changes and return back to control mode"
	[Exit]="Discard current changes and exit the script"
    )

    echo
    echo -e "${GREEN}Available Options:${RESET}"
    for option in "${!options[@]}"; do
        echo -e "${BLUE}$option:\n\t\t${YELLOW}${options[$option]}${RESET}\n"
    done
    echo
}

# Use FZF to select section and prints the selection
function SelectSection {
    printf "%s\n" "${SERVICE_SECTIONS[@]}" \
        | fzf -e --header "Select Section" --prompt "Section: "
}

# Use FZF to select section directive and prints the selection
function SelectDirective {
    SectionDirectives "$1"
    printf "%s\n" "${!SECTION_DIRECTIVES[@]}" \
        | fzf -e --header "Select Directive" --prompt "Directive: "
}

# Use FZF (SelectSection, SelectDirective) to generate key and prints it
function SelectKey {
    # ask for section name
    section="$(SelectSection)"
    [ -z "$section" ] && return 1
    
    # ask for directive name
    directive="$(SelectDirective "$section")"
    [ -z "$directive" ] && return 1

    # generate and return key
    echo "${section}:${directive}"
}

# the edit service mode script
function EditService {
    local service_path="$1"
    local service_file
    service_file="$(basename "$service_path")"
    local service_name=${service_file%.service}

    # Read the service file
    if ! ReadService "$service_path"; then
        display_error "Failed to read service file." 1
        return 1
    fi

    declare -a options=("List" "List Section" "Copy Value" "Set" "Set Manual"
        "Set Current Working Directory"
        "Set User" "Set Group" "Set Type"
        "Control Mode" "Help" "Reload" "Save" "Back" "Exit")

    echo -e "${YELLOW}"
    select choice in "${options[@]}"; do
        case "$choice" in
            List) PrintService | less -SR;;
            "List Section")
                section="$(SelectSection)"
                [ -z "$section" ] && continue
                SectionDirectives "$section"
                less -SR < <(echo -e "${MAGENTA}[$section]${RESET}"
                for directive in "${!SECTION_DIRECTIVES[@]}"; do
                    value="${SECTION_DIRECTIVES[$directive]}"
                    echo -e "${BLUE}$directive${GREEN} = ${YELLOW}$value${RESET}"
                done);;
            "Copy Value")
                key="$(SelectKey)"
                [ -z "$key" ] && continue
                section="$(KeySection "$key")"
                directive="$(KeyDirective "$key")"
                value="$(KeyValue "$key")"
                xclip -sel clip <<< "$value" \
                    && display_success "Value of (${BLUE}$key${WHITE}) copied to clipboard: ${YELLOW}$value${RESET}";;
            "Set Manual")
                local abort_set=false
                local key="Unit:Description"

                while true; do
                    read -re -p "${MAGENTA}Enter key (set empty to cancel): ${YELLOW}" -i "$key" key
                    if [ -z "$key" ]; then abort_set=true; break; fi
                    if ! expr "$key" : '^.*:.*$' > /dev/null 2>&1; then
                        display_error "Invalid key format: $key" 1
                        continue
                    fi
                    break
                done

                # if about then continue
                if $abort_set; then continue; fi

                value="$(KeyValue "$key")"
                read -re -p "${MAGENTA}Enter value for ${BLUE}$key${RESET} (set empty to remove): ${YELLOW}" -i "$value" value
                echo -en "${RESET}"
                if [ -n "$value" ]; then
                    SERVICE[$key]="$value"
                else
                    unset "SERVICE[$key]"
                fi
                # Update SERVICE_SECTIONS array
                ServiceSections;;
            Set)
                key=$(SelectKey)
                [ -z "$key" ] && continue
                value="$(KeyValue "$key")"
                read -re -p "${MAGENTA}Enter value for ${BLUE}$key${RESET}: ${YELLOW}" -i "$value" value 
                echo -ne "${RESET}"
                if [ -n "$value" ]; then
                    SERVICE[$key]="$value"
                else
                    unset "SERVICE[$key]"
                fi
                # Update SERVICE_SECTIONS array
                ServiceSections;;
            "Set Current Working Directory")
                SERVICE["Service:WorkingDirectory"]="$(pwd)";;
            "Set User")
                SERVICE["Service:User"]="$(getent passwd \
                    | cut -d: -f1 \
                    | fzf -e --header "Select User" --prompt "User: " --query "$(id -un)")";;
            "Set Group")
                SERVICE["Service:Group"]="$(getent group \
                    | cut -d: -f1 \
                    | fzf -e --header "Select Group" --prompt "Group: " --query "$(id -gn)")";;
            "Set Type")
                key="Service:Type"
                value=$(KeyValue $key)
                value=${value:-"simple"}
                service_type=(simple forking oneshot dbus notify)
                selections="$(printf "%s\n" "${service_type[@]}"\
                    | fzf -e -m --disabled --header "Select Service Types(use tab for multi selections): $value"\
                    | tr '\n' '|')"
                SERVICE[$key]="${selections:0:-1}";;
            Save) SaveService "$service_path" && break;;
            "Control Mode") ControlService "$service_path" && break;;
            Help) DisplayEditModeHelp | less -SR;;
            Reload) 
                if ! ReadService "$service_path"; then
                    display_error "Failed to read service file." 1
                    break
                fi;;
            Back) break;;
            Exit) exit 0;;
            *) display_error "Invalid Choice" 1;;
        esac
    done
}

# print the help message for the control mode
function DisplayControlServiceHelp {
    declare -A options=(
    [Status]="Show service status"
    [Start]="Start the service"
    [Stop]="Stop the service"
    [Restart]="Restart the service"
    [Enable]="Enable the service to start at boot time"
    [Disable]="Disable the service to start at boot time"
    [Print]="Print the service configuration"
    [Logs]="Show the service logs"
    ["Follow Logs"]="Show the service logs and wait for new updates"
    [Edit]="Enter edit mode to edit the service"
    [Help]="Show this help message"
    [Editor]="Open the service file in a text editor (\$EDITOR)"
    [Remove]="Stop, Disable then Remove the service"
    [Clipboard]="Copy the service file content into your system clipboard"
    [Copy]="Copy the service configuration to a new name"
    [Rename]="Rename the service to a new name"
    [Create Service]="Create a new service"
    [Select Service]="Select another service"
    [Back]="Go back one step"
    [Exit]="Exit this script"
)

    echo
    echo -e "${GREEN}Available Options:${RESET}"
    for option in "${!options[@]}"; do
        echo -e "${BLUE}$option:\n\t\t${YELLOW}${options[$option]}${RESET}\n"
    done
    echo
}

# the control service mode script
function ControlService {
    local service_path="$1"
    local service_file
    service_file="$(basename "$service_path")"
    local service_name=${service_file%.service}

    local options=("Status" "Start" "Stop" "Restart" "Enable" "Disable" "Print"
        "Logs" "Follow Logs" "Edit" "Editor" "Rename" "Copy" "Remove" "Clipboard"
        "Create Service" "Select Service" "Help" "Back" "Exit")

    # show service status
    echo -e "${BLUE}"
    systemctl status "$service_file" | head -n 3

    echo -e "${YELLOW}"
    select option in "${options[@]}"; do
        echo -en "${RESET}"
        case "$option" in
            "Help") DisplayControlServiceHelp | less -SR;;
            "Start") sudo systemctl start "$service_file";;
            "Restart") sudo systemctl restart "$service_file";;
            "Stop") sudo systemctl stop "$service_file";;
            "Enable") sudo systemctl enable "$service_file";;
            "Disable") sudo systemctl disable "$service_file";;
            "Status") systemctl status "$service_file";;
            "Logs") journalctl -u "$service_file";;
            "Follow Logs") journalctl -u "$service_file" -f;;
            "Print") systemctl cat "$service_file";;
            "Editor") sudo bash -c "$EDITOR $service_path";;
            "Edit") EditService "$1";;
            "Copy") CopyMoveService "$1" "cp" && break;;
            "Rename") CopyMoveService "$1" "mv" && break;;
            "Clipboard") systemctl cat "$service_file" \
                | xclip -sel clip && display_success "Service content copied to clipboard";;
            "Remove")
                sudo systemctl stop "$service_file" > /dev/null 2>&1
                sudo systemctl disable "$service_file" > /dev/null 2>&1
                sudo rm "$service_path" > /dev/null 2>&1
                sudo systemctl daemon-reload > /dev/null 2>&1
                display_success "Service Removed!"
                break;;
            "Create Service") CreateService && break;;
            "Select Service") SelectService && break;;
            "Back") break;;
            "Exit") exit 0;;
            *) display_error "Invalid Choice" 1;;
        esac
    done
}

# Copy/Move script from path to path
function CopyMoveService {
    local service_path="$1"
    local service_file
    service_file="$(basename "$service_path")"
    local service_name=${service_file%.service}
    local new_service_name="$service_name"

    # get service name
    while true; do
        read -re -p "${GREEN}Enter service name: ${YELLOW}" -i "$new_service_name" new_service_name
        # if no service exists with the same name then goto next step
        ServiceExists "$new_service_name" || break
        # display error and loop if service with the same name exists
        display_error "A service with the same name exists!" 1
    done

    # copy the service with a new name
    local new_path="${SYSD}${new_service_name}.service"
    if sudo bash -c "$2 '$service_path' '$new_path'"; then
        display_success "Service copied to $new_path"
        ControlService "$new_path"
    else
        display_error "Failed to copy the service, Exiting..."
    fi
}

# Returns 0 if "$1: service" exists otherwise 1
function ServiceExists {
    local service="$1"
    service="$(basename "$service")"
    service="${service%.service}"

    test -f "${SYSD}${service}.service" && return 0
    ReloadSystemD
    LoadServices | grep -e "^${service}.service\$" > /dev/null 2>&1
}

# create service mode script
function CreateService {
    display_info "Create a new service"
    local service_name=""

    # get service name
    while true; do
        read -re -p "${GREEN}Enter service name: ${YELLOW}" -i "$service_name" service_name
        # if no service exists with the same name then goto next step
        ServiceExists "$service_name" || break
        # display error and loop if service with the same name exists
        display_error "A service with the same name exists!" 1
    done

    # get service description
    read -p "${GREEN}Enter service description: ${YELLOW}" -r service_description

    local service_content="[Unit]
    Description=${service_description}

    [Install]
    WantedBy=multi-user.target
    "

    # generate service path
    local service_path="${SYSD}${service_name}.service"
    # write service content to file
    if sudo bash -c "echo '$service_content' > $service_path"; then
        display_success "Service file created at ${service_path}"
        ControlService "${service_path}"
    else
        display_error "Failed to write service file to $service_path, Exiting..."
    fi
}

# Reload SystemD Daemons with a printed message
function ReloadSystemD {
    sudo systemctl daemon-reload
}

# Get all systemd unit file names
function LoadServices {
    systemctl list-unit-files --type=service | awk '$1 ~ ".service"{print $1}'
}

# Use FZF to select a service from filtered list then print its fullpath
function SelectService {
    local service=""

    # reload systemd services
    ReloadSystemD
    # use fzf to select a service from filtered list
    service=$(LoadServices | fzf -e --header "Select Service" --prompt "Service: ")

    # check if a service was selected
    if [ -z "$service" ]; then
        display_error "Please select service!" 1
        return
    fi

    # get service file path
    service_path=$(systemctl show -p FragmentPath "$service" | cut -d'=' -f2 )

    # print the service fullpath
    echo "$service_path"
}

# Main Script

function main {
    PS3="${MAGENTA}Selected Action: ${YELLOW}"
    local actions=(
        "Create Service"
        "Select Service"
        "Edit Service"
        "Exit"
    )

    echo -e "${GREEN}How can I help?${BLUE}"
    select action in "${actions[@]}"; do
        echo -e "${RESET}"
        case $action in
            "Create Service") CreateService;;
            "Select Service")
                display_info "Reloading SystemD Daemons!!!"
                fullpath="$(SelectService)"
                [ -z "$fullpath" ] || ControlService "$fullpath";;
            "Edit Service")
                display_info "Reloading SystemD Daemons!!!"
                fullpath="$(SelectService)"
                [ -z "$fullpath" ] || EditService "$fullpath";;
            "Exit") exit 0;;
            *) display_error "Invalid Choice" 1 ;;
        esac
    done
}

# Run main function
main
